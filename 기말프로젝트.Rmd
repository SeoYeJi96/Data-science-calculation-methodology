---
title: "기말프로젝트 "
author: "G202358002 서예지"
date: "2024-06-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1번. 
(a) 먼저 N=1000명 중에서 한 명을 뽑아 초기 감염자를 1명으로 고정하고 감염된 사람과 접촉이 이루어질 때 감염이 전파된다. 감염자는 1로 건강한 사람은 0으로 표시를 하여 업데이트 한 후 결과를 반환한다. 결과에서 1000명이 감염될 때까지의 시간과 감염과정은 다음과 같다.
```{r}
# SIR 모델 시뮬레이션 함수
simulate_SIR <- function(N, a, t) {
  total <- rep(0, N)
  first <- sample(1:N, 1, replace = FALSE)
  total[first] <- 1
  
  I <- numeric(t)
  S <- numeric(t)
  
  I[1] <- sum(total == 1)
  S[1] <- sum(total == 0)
  
  for (time in 2:t) {
    # 접촉이 이루어질 두 사람 선정
    contacts <- sample(1:N, 2, replace = FALSE)
    
    if (sum(total[contacts]) == 1) {
      if (runif(1) < a) {
        total[contacts] <- 1
      }
    }
    # 감염자 및 건강한 사람 수 업데이트
    I[time] <- sum(total == 1)
    S[time] <- sum(total == 0)
    
  }
  return(list(S = S, I = I))
}

N <- 1000        
a <- 0.1     
t<- 100000

sir <- simulate_SIR(N, a, t)
time_1000 <- which(sir$I >= 1000)[1]

# 감염과정
df <- data.frame(Time = 1:100000, Susceptible = sir$S, Infected = sir$I)

# 1000명이 감염될 때까지의 시간
cat("1000명이 감염될 때까지 걸린 시간:", time_1000, "일\n")
```

(b) (a)의 결과와 비교하였을 때, (a)는 치유확률이 없으므로 감염자 수가 시간이 지남에 따라 증가하는 반면에 (b)는 0.01의 확률로 치유되기 때문에 감염자 수가 급격하게 증가하지 않고 어느 시점에서 평형 상태에 도달하거나 다시 감소한다. 따라서, (a)의 경우 감염이 계속 확산 되는 반면에 (b)의 경우에는 감염이 어느 정도 억제되고 제어될 수 있다는 것을 알 수 있다.
```{r}
# SIR 모델 시뮬레이션 함수
simulate_SIR <- function(N, a, b, t) {
  total <- rep(0, N)
  first <- sample(1:N, 10, replace = FALSE)
  total[first] <- 1
  
  I <- numeric(t)
  S <- numeric(t)
  
  I[1] <- sum(total == 1)
  S[1] <- sum(total == 0)
  
  for (time in 2:t) {
    # 접촉이 이루어질 두 사람 선정
    contacts <- sample(1:N, 2, replace = FALSE)
    
    if (sum(total[contacts]) == 1) {
      if (runif(1) < a) {
        total[contacts] <- 1
      }
    }
    total[total == 1] <- rbinom(sum(total==1),1,1-b)
    # 감염자 및 건강한 사람 수 업데이트
    I[time] <- sum(total == 1)
    S[time] <- sum(total == 0)
    
  }
  return(list(S = S, I = I))
}

N <- 100        
a <- 0.1     
t<- 100000
b <- 0.01

sir <- simulate_SIR(N, a, b, t)
# 감염과정
df <- data.frame(Time = 1:100000, Susceptible = sir$S, Infected = sir$I)
```

(c)-(a). 접촉간 시간이 평균 5인 지수분포인 경우에 대하여 (a)를 실시한 결과이다. (a)에서보다 감염 확산이 느려졌다.
```{r}
# SIR 모델 시뮬레이션 함수
simulate_SIR<- function(N, a, t, lambda, start) {
  total <- rep(0, N)
  initial <- sample(1:N, 10, replace = FALSE)
  total[initial] <- 1
  
  I <- numeric(t)
  S <- numeric(t)
  
  I[1] <- sum(total == 1)
  S[1] <- sum(total == 0)
  
  for (time in 2:t) {
    # 접촉 횟수를 포아송 분포로 결정
    exp_Contacts <- rpois(1, lambda = 1 / lambda)
    
    if (exp_Contacts > 0) {
      for (contact in 1:exp_Contacts) {
        contacts <- sample(1:N, 2, replace = FALSE)
        
        if (sum(total[contacts]) == 1) {
          if (runif(1) < a) {
            total[contacts] <- 1
          }
        }
      }
    }
    
    # 감염자 및 건강한 사람 수 업데이트
    I[time] <- sum(total == 1)
    S[time] <- sum(total == 0)
  }
  
  return(list(S = S, I = I))
}

N <- 1000        
a <- 0.2   
t <- 100000
lambda <- 5

sir <- simulate_SIR(N, a, t, lambda, start)

# 감염과정
df <- data.frame(Time = 1:100000, Susceptible = sir$S, Infected = sir$I)

# 그래프 출력
plot(df$Time, df$Infected, type = 'l', col = 'red')
lines(df$Time, df$Susceptible, type = 'l',col = 'blue')
legend("right", legend = c("Infected", "Susceptible"), col = c("red", "blue"), lty = 1)
```

(c)-(b). 접촉간 시간이 평균 5인 지수분포인 경우에 대하여 (b)를 실시한 결과이다.
```{r}
# SIR 모델 시뮬레이션 함수
simulate_SIR <- function(N, a, b, t) {
  total <- rep(0, N)
  first <- sample(1:N, 10, replace = FALSE)
  total[first] <- 1
  
  I <- numeric(t)
  S <- numeric(t)
  
  I[1] <- sum(total == 1)
  S[1] <- sum(total == 0)
  
  for (time in 2:t) {
    # 접촉 횟수를 포아송 분포로 결정
    exp_Contacts <- rpois(1, lambda = 1 / lambda)
    
    if (exp_Contacts > 0) {
      for (contact in 1:exp_Contacts) {
        contacts <- sample(1:N, 2, replace = FALSE)
        
        if (sum(total[contacts]) == 1) {
          if (runif(1) < a) {
            total[contacts] <- 1
          }
        }
      }
    }
    
    total[total == 1] <- rbinom(sum(total==1),1,1-b)
    # 감염자 및 건강한 사람 수 업데이트
    I[time] <- sum(total == 1)
    S[time] <- sum(total == 0)
    
  }
  return(list(S = S, I = I))
}

N <- 1000        
a <- 0.5  
t<- 100000
b <- 0.0001
lambda <- 5

sir <- simulate_SIR(N, a, b, t)

# 감염과정
df <- data.frame(Time = 1:100000, Susceptible = sir$S, Infected = sir$I)

# 그래프 출력
par(mfrow=c(1,2))
plot(df$Time, df$Infected, type = 'l', col = 'red')
plot(df$Time, df$Susceptible, type = 'l',col = 'blue')
```

## 2번.
(a) $\mu,\sigma^2$을 각각 두 수준씩 잡고 그래프로 그려본 결과는 다음과 같다. $\mu$를 동일하게 하고 $\sigma^2$을 각각 0.01, 0.05로 설정하였을 때, $\sigma^2$이 작은 경우에 변동성이 작으므로 등락폭이 크지 않은 결과를 볼 수 있었고, 반대로 $\sigma^2$이 큰 경우에는 변동성이 크므로 주가의 변동이 크고 상승과 하락을 반복하며 등락폭이 큰 경향을 볼 수 있었다. 즉, $\sigma^2$이 클수록 주가 변동성이 커져 risk가 증가함을 의미한다. 또한, $\sigma^2$을 동일하게 하고 $\mu$를 각각 0.05, 0.1로 설정하였 때, $\mu$가 클수록 주가는 평균적으로 더 높은 속도로 상승하는 경향이 있음을 알 수 있다.
```{r}
# 함수 정의
sim <- function(mu, sigma2, S0, t) {
  N <- t 
  S <- numeric(N)
  S[1] <- S0

  for (i in 2:N) {
    Z <- rnorm(1,mean=0,sd=1)
    S[i] <- S[i-1] * exp((mu - sigma2/2) + sqrt(sigma2) * Z)
  }
  
  return(S)
}

mu1 <- 0.05; sigma1 <- 0.01
mu2 <- 0.1; sigma2 <- 0.05
S0 <- 100; t <- 10000

# 각 모수 조합에 대한 주가
S1 <- sim(mu1, sigma1, S0, t)
S2 <- sim(mu1, sigma2, S0, t)
S3 <- sim(mu2, sigma1, S0, t)
S4 <- sim(mu2, sigma2, S0, t)

# 그래프 출력
par(mfrow=c(2,2))
plot(1:t, S1, type="l", main=paste0("mu=", mu1, ", sigma2=", sigma1))
plot(1:t, S2, type="l", main=paste0("mu=", mu1, ", sigma2=", sigma2))
plot(1:t, S3, type="l", main=paste0("mu=", mu2, ", sigma2=", sigma1))
plot(1:t, S4, type="l", main=paste0("mu=", mu2, ", sigma2=", sigma2))

```

(b)
세 조합에 대하여 $E[S(t)]$와 $P(S(t)>S(0))$를 추정하고 각 추정치의 95% 신뢰구간을 구한 결과는 다음과 같다.
```{r}
sim <- function(mu, sigma2, S0, t) {
  N <- t
  S <- numeric(N)
  S[1] <- S0
  
  for (i in 2:N) {
    Z <- rnorm(1, mean = 0, sd = 1)
    S[i] <- S[i - 1] * exp((mu - sigma2 / 2) + sqrt(sigma2) * Z)
  }
  
  return(S)
}

# (mu, sigma^2)의 세 조합
params <- list(
  list(mu = 0.05, sigma2 = 0.0025),
  list(mu = 0.01, sigma2 = 0.0025),
  list(mu = 0.01, sigma2 = 0.01)
)

# 추정치 계산
estimate_mean_prob <- function(mu, sigma2, S0, t, B = 5000) {
  S_t <- sim(mu, sigma2, S0, t)
  exp_mu_t <- exp(mu * t)
  mean_est <- mean(S_t)
  prob_est <- mean(S_t > S0)
  
  boot_means <- numeric(B)
  boot_probs <- numeric(B)
  
  for (i in 1:B) {
    boot_sample <- sample(S_t, replace = TRUE)
    boot_means[i] <- mean(boot_sample)
    boot_probs[i] <- mean(boot_sample > S0)
  }
  
  # 95% 신뢰구간 계산
  mean_ci <- quantile(boot_means, c(0.025, 0.975))
  prob_ci <- quantile(boot_probs, c(0.025, 0.975))
  
  return(list(
    mean_est = mean_est,
    exp_mu_t =  exp_mu_t,
    mean_ci = mean_ci,
    prob_est = prob_est,
    prob_ci = prob_ci,
    S_t = S_t
  ))
}

results <- lapply(params, function(param) {
  estimate_mean_prob(param$mu, param$sigma2, S0 = 100, t = 10000)
})

for (i in 1:length(params)) {
  cat("mu =", params[[i]]$mu, ", sigma2 =", params[[i]]$sigma2, "\n")
  cat("exp(mut) =", exp(params[[i]]$mu*10000), "\n")
  cat("E[S(t)]:", results[[i]]$mean_est, "\n")
  cat("95% Confidence Interval for E[S(t)]:", results[[i]]$mean_ci, "\n")
  cat("P(S(t) > S0):", results[[i]]$prob_est, "\n")
  cat("95% Confidence Interval for P(S(t) > S0):", results[[i]]$prob_ci, "\n\n")
}

```

## 3번.
(a) 역변환법을 이용하여 $Pa(3,100000)$분포로부터 난수 10000개를 발생시킨 함수는 다음과 같다. 
```{r}
pa = function(n,a,b){
  num=b/((1-runif(n))^(1/a))
  return(num)
}
rpa=pa(10000,3,100000)
```

히스토그램과 pdf를 겹쳐 그린 결과 아래와 같이 거의 일치함을 알 수 있다.
```{r}
pdf = function(x,a,b){
  return((a*(b^a))/(x^(a+1)))
}
curve(pdf(x,3,100000),xlim=c(100000,500000),type='l')
hist(rpa,breaks=seq(100000,7000000,5000),freq=FALSE,add=TRUE)
```

(b) 1000번의 독립적 시행에서 각 시행이 확률 0.01을 가지므로 보험청구 고객수는 이항분포를 따른다. 따라서 반복문을 돌려 $Z(1), ..., Z(5)$를 구할 수 있으므로 이를 이용하여 x축은 년도를 y축은 자산인 plot을 그리면 다음과 같다.
```{r}
asset <- 1000000
n <- 1000
premium <- 5500
p <- 0.01
alpha <- 3
beta <- 100000
years <- 5

Z <- numeric(years+1)
Z[1] <- asset

for (t in 1:years) {
  if(Z[t] == 0){
    Z[t+1:years+1] <- 0
    next
   } 
    N <- rbinom(1, n, p)
    X_t <- sum(pa(N, alpha, beta))
    Z[t+1] <- max(Z[t] + n * premium - X_t, 0) 
  }

print(Z)
years_vector <- 1:years
plot(years_vector, Z[2:6], type = "o", xlab = "Year", ylab = "Assets")
```

시뮬레이션 횟수를 10000번으로 설정하여 실행하면 회사가 파산할 확률과 5년 후의 자산의 기대값은 다음과 같다. 
```{r}
asset <- 1000000
n <- 1000
premium <- 5500
p <- 0.01
alpha <- 3
beta <- 100000
years <- 5

# 시뮬레이션 횟수
MC <- 10000

last <- numeric(MC)

for (i in 1:MC) {
  Z <- numeric(years+1)
  Z[1] <- asset

  for (t in 1:years) {
    if (Z[t] == 0) {
      Z[(t+1):(years+1)] <- 0  # 파산 시 그 이후 모두 0
      next 
    }
    
    N <- rbinom(1, n, p)
    X_t <- sum(pa(N,alpha, beta))
    Z[t+1] <- max(Z[t] + n * premium - X_t, 0)
  }
  
  last[i] <- Z[6]
}

# 회사가 파산할 확률 
bankruptcy <- mean(last == 0)

# 5년 후의 자산의 기대값
expect <- mean(last)

cat("회사가 파산할 확률:", bankruptcy, "\n")
cat("5년 후의 자산의 기대값:", expect, "\n")
```

(c) 이익 배당을 하는 경우 회사가 파산할 확률, 5년 후 자산의 기대값, 5년 동안 총 이익배당의 기대값을 추정한 결과는 다음과 같다. (b)의 모의실험에서 얻은 값과 비교하였을 때 회사가 파산할 확률은 약간 증가하나 이익 배당을 하는 경우에 5년 후 자산의 기대값이 확연하게 줄은 것을 알 수 있다.
```{r}
asset <- 1000000
n <- 1000
premium <- 5500
p <- 0.01
alpha <- 3
beta <- 100000
years <- 5

# 시뮬레이션 횟수
MC <- 10000

last <- numeric(MC)
total_dividends <- numeric(MC)

for (i in 1:MC) {
  Z <- numeric(years + 1)
  Z[1] <- asset
  dividends <- 0

  for (t in 1:years) {
    if (Z[t] == 0) {
      Z[(t + 1):(years + 1)] <- 0  # 파산 시 그 이후 모두 0
      next 
    }
    N <- rbinom(1, n, p)
    X_t <- sum(pa(N, alpha, beta))
    Z[t + 1] <- max(Z[t] + n * premium - X_t, 0)

    if (Z[t + 1] > 1000000) {
      dividends <- dividends + (Z[t + 1] - 1000000)
      Z[t + 1] <- Z[t + 1] - (Z[t + 1] - 1000000)
    }
    
    Z[t + 1] <- max(Z[t + 1], 0)
  }
  
  last[i] <- Z[6]
  total_dividends[i] <- dividends
}

# 회사가 파산할 확률
bankruptcy <- mean(last == 0)

# 5년 후의 자산의 기대값
expect <- mean(last)

# 5년동안 총 이익배당의 기댓값
expect_dividends <- mean(total_dividends)

cat("회사가 파산할 확률:", bankruptcy, "\n")
cat("5년 후의 자산의 기대값:", expect, "\n")
cat("5년간 총 이익배당의 기댓값:", expect_dividends, "\n")
```
